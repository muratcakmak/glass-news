// VAPID implementation for Cloudflare Workers
// Replaces web-push library to avoid nodejs runtime issues

function base64UrlToUint8Array(base64Url: string): Uint8Array {
	const padding = "=".repeat((4 - (base64Url.length % 4)) % 4);
	const base64 = (base64Url + padding).replace(/\-/g, "+").replace(/_/g, "/");
	const rawData = atob(base64);
	const outputArray = new Uint8Array(rawData.length);
	for (let i = 0; i < rawData.length; ++i) {
		outputArray[i] = rawData.charCodeAt(i);
	}
	return outputArray;
}

function uint8ArrayToBase64Url(uint8Array: Uint8Array): string {
	const base64 = btoa(String.fromCharCode(...uint8Array));
	return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

async function signData(data: string, privateKey: string): Promise<string> {
	const keyData = base64UrlToUint8Array(privateKey);
	const key = await crypto.subtle.importKey(
		"jwk",
		{
			kty: "EC",
			crv: "P-256",
			x: "", // Not needed for private key import if we have d? Wait, for JWK import we need full key usually?
			// Actually, usually privateKey string is just the 'd' value or a PEM?
			// 'web-push' generate-vapid-keys gives base64url encoded strings.
			// The private key from web-push is usually just the 32 bytes of 'd'.
			// We need to reconstruct the JWK.

			// Let's assume privateKey input is the base64url string of 'd'.
			// To import as JWK for signing, we strictly need:
			// kty: 'EC', crv: 'P-256', d: ...
			// x and y are public parameters.
			// Ideally we should import as PKCS8 if it was PEM, but here it's likely raw scalar.

			// Actually, web-push private key is usually just the raw bytes.
			// Let's try importing as 'raw' doesn't work for EC private keys in Web Crypto commonly?
			// Check how to import raw private scalar.
			// Simple way: construct a JWK.
			d: privateKey,
			ext: true,
		},
		{
			name: "ECDSA",
			namedCurve: "P-256",
		},
		false,
		["sign"],
	);
	// Wait, importKey 'jwk' requires all parts for strict implementations?
	// Cloudflare Workers usually accepts partial JWK for private key if d is present?
	// Let's rely on a more robust import strat or assume standard web-push keys.

	// UPDATE: VAPID keys generated by web-push are 32 bytes 'd' (private) and 65 bytes uncompressed point (public).

	// Let's try importing the private key.
	// Constructing a JWK with just 'd' might fail if x/y are missing.
	// However, if we can't derive x/y easily from d without a library (elliptic),
	// we might need to assume the valid JWK format or use a trick.

	// Alternative: Use the web-push library's VAPID keys but implement the send logic manualy?
	// No, I want to avoid the library.

	// Let's try a standard minimal JWK.
	const keyImport = await crypto.subtle.importKey(
		"jwk",
		{
			kty: "EC",
			crv: "P-256",
			d: privateKey,
			x: "", // Providing empty string might fail.
			y: "",
		},
		{ name: "ECDSA", namedCurve: "P-256" },
		false,
		["sign"],
	);

	const encoder = new TextEncoder();
	const signature = await crypto.subtle.sign(
		{
			name: "ECDSA",
			hash: { name: "SHA-256" },
		},
		keyImport,
		encoder.encode(data),
	);

	return uint8ArrayToBase64Url(new Uint8Array(signature));
}
// Actually, deriving the public key from private key in pure Web Crypto is hard without x/y.
// But wait, the VAPID_PRIVATE_KEY from web-push is usually 32 bytes (64 chars hex or 43 chars base64url).
// The JWK import requires x and y.

// SOLUTION:
// I will rewrite the VAPID token generation to use a simplified flow, but honestly getting the crypto right is tricky.
// Better plan: use `web-push` for generating the token (if that part doesn't rely on https) and then use fetch.
// Most of `web-push` logic is platform agnostic until it sends the request.
// The error was `[unenv] https.request`.
// So if I can use `web-push` to GENERATE the headers, but use `fetch` to send, that's the winner.
